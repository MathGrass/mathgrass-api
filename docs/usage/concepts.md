# Concepts & Domain
Explanation of the employed data structures (Graph, Task,..)

## Architecture
![Architecture](../images/architecture.png?raw=true "Architecture")


## DTO Model
- Generated by swagger codegen spec (see `openapi-spec/graphex-minimal.yaml`)

## Entity Relationship Diagram (used in DB)

![Entity Relationship Diagram](../images/er-diagram.png?raw=true "Entity Relationship Diagram")


## Model Breakdown
For better understanding of the model, we will break it down into a few parts:
### Task
A `Task` describes a fully defined task on solving a problem on a certain graph.
In order to distinguish between static tasks and dynamic tasks a task can (but does not necessarily have to) contain a `TaskTemplate`. If it contains a TaskTemplate, it can be considered a dynamic task otheriwse it's a static one (which is associated to a static answer string). A task template can be used in multiple tasks and it's purpose is providing the same exercise (with the same evaluation script) for different tasks (i.e. different graphs). This way the teacher can create one general task description, which can be associated with different graphs. For managing evaluation scripts there is the `TaskSolver`
Students can submit `Feedback` for tasks. This feedback is not evaluated by the system, but can be used by the teacher to improve the task description.
Teachers can setup `TaskHints` for tasks. These hints are shown to the student if he/she requests them individually.
To group and categorize tasks, they can be put into `TaskGroups` and `TaskCollections`. A task can be part of multiple groups and collections.

### Graph
Entities like `Graph`, `Vertex` and `Edge` obviuosly represent the graph data structure.

### Tags
`Tags` can be used to categorize tasks and graphs. They are used in the frontend to filter task templates and graphs.

### TaskResult
As soon as a student submits a solution to the API it gets recorded as a `TaskResult` in the database. 
After the solution has been checked/evaluated (using the static answer or the Evaluator service) the attribute answerTrue is written so that the TaskResult is complete.





## Services

### Message Bus
- Api and evaluator use localhost as message bus host for RabbitMQ
-- queues

### API
- When the API is started the swagger UI is available at `http://localhost:8080/swagger-ui.html`
- API und DB models are transformed to each other by classes that inherit from ModelTransformer under `src/main/java/de/tudresden/inf/st/mathgrassserver/transform`

### Evaluator
The Evaluator is a direct member of the Top Level Architecture and can be considered a microservice. It is responsible for the evaluation of submitted task solutions which are transferred by the API over the message bus. For isolation purposes it uses docker containers as computing instances for the actual evaluation process. Since the main purpose of this application is to evaluate mathematical tasks (especially tasks about graphs) every docker container used here is based on the Sage Math docker image.

The basic configuration uses the `BasicEvaluator` (see below) in order to describe the procedure of the current evaluation process.


#### Docker Manager (`docker_manager.py` and `docker_container.py`)
The Docker Manager keeps track of allocated and free docker containers. Besided the preparation of the containers in advance it also removes them after they finished their respective evaluation request.
As a result a docker container is only used for a single task solution evaluation. The reason behind that lays in the desired degree of isolation. 
In order to decrease latency when doing so it is possible to specify a constant which descibes how many docker containers should be prepared in advance. Also a maximum can be declared but if this limit is reached further requests will be discared for now.

#### AbstractEvaluator (`abstract_evaluator.py`)
The AbstractEvaluator contains an interface in order enable the implementation of different evaluation procedures. It is kept lean:
First, every sub instance of the AbstractEvaluator can declare the name of the message bus queue which it will receive requests from. And second it defines a callback which is invoked when the evaluator receives a message from the selected queue.

#### BasicEvaluator (`basic_evaluator.py`)
Once the basic evaluator receives an evaluation request (containing a request id, a taks id and the submitted soluation) it will trigger a bunch of steps. These consist of the following:
- allocating a container using the docker manager
- loading the graph as well as the evaluation script from the database using the task id
- base64 encoding the just loaded graph and the submitted solution
- uploading the script as a file (named eval.sage)
- executing the script in the container with command `sage eval.sage <answer-as-base64> <graph-as-base64>`
